BTK ALGORÄ°TMA VE VERÄ° YAPILARI Ä°LERÄ° SEVÄ°YE ---> C# Programlama dili
01 Intro
02 Algorithm Analysis and Asymptotic Notations
03 Array and Collections
04 Linked List
05 Stack
06 Queue
07 Trees
08 Priority Queue and Heap
09 Disjoint Sets
10 Graph
11 Graph-based Algorithms
12 Sorting Algorithms

KazanÄ±mlar
- Verinin bellek Ã¼zerinde organizasyonu kavramak
- DoÄŸrusal ve DoÄŸrusal olmayan veri yapÄ±larÄ±nÄ± aÃ§Ä±klamak
- DoÄŸrusal ve DoÄŸrusal olmayan veri yapÄ±larÄ±nÄ± kodlayabilmek
- Recursive ve Generic kodlama becerisi geliÅŸtirmek
- Veri yapÄ±larÄ±nÄ± ile iliÅŸkili algoritmalar hakkÄ±nda bilgi sahibi olur
- Algoritma tasarÄ±m stratejileri hakkÄ±nda bilgi sahibi olmak
- Ã–zgÃ¼n veri tÃ¼rleri tasarlayÄ±p, kodlamak

C# Components: Delegate, Event, Generic, Dynamic, LINQ
  Lambda Expression, expression-bodied members,getters,and setter


Veri YapÄ±sÄ± (Data Structure)
  Veri yapÄ±sÄ±, veriye eriÅŸimi, verinin depolanmasÄ±nÄ± ve verinin organizasyonunu temsil eden bir kavramdÄ±r.
  Bir veri yapÄ±sÄ±, veri deÄŸerleri, veriler arasÄ±ndaki iliÅŸkiler ve verilere uygulanabilecek iÅŸlevler veya iÅŸlemlerin bir koleksiyonudur.
  Probleme uygun bir veri kullanÄ±p verileri organize etmek


Veri YapÄ±sÄ±, Veriyi iÅŸlemek manipÃ¼le etmek iÃ§in kullanÄ±lmasÄ± gereken mekanizmalara ihtiyaÃ§ var

# Veri YapÄ±larÄ± (Data Structures)
Linear                            
  Array
    single dimension array
    multi dimension array
  List
    array list
    generic list
    sorted list
    linked list
  Stack
  Queue
  
Non-Linear
  Graph
    Tree
      Binary Tree
        Binary Search Tree
          Self Balancing Tree
            AVL Tree
            Red-Black Tree
    
    Heap
      Binary heap
      Binominal heap
      Fibonacci heap
      
      

# Veri TÃ¼rleri (Data Types)
Data Types: Value Types, Reference Types
            Value Types: struct, enum
            Reference Types: class, interface, delegate
            
Built-in data type (value): short, int, double, char, decimal            
Built-in data type (reference): object, string, dynamic         

Custom/user defined data type (value): struct
Custom/user defined data type (reference): class      (OOP)





# VERÄ°NÄ°N BELLEK ÃœZERÄ°NDEKÄ° ORGANÄ°ZASYONU

DeÄŸiÅŸken (Valuable)
HafÄ±zada ayrÄ±lan yere bir deÄŸer yer ayÄ±rmak atamak, gerekli durumlarda ayrÄ±lan yere deÄŸer atamak, deÄŸeri deÄŸiÅŸtirmek ve okumak iÃ§in kullanÄ±lan programlama bileÅŸeni deÄŸiÅŸken olarak adlandÄ±rÄ±lÄ±r.
â€¢ Bir baÅŸka ifadeyle deÄŸiÅŸken, bir deÄŸeri tutan depolama konumudur.
â€¢ DeÄŸiÅŸken, Ã¼Ã§ temel boyutu ile dÃ¼ÅŸÃ¼nÃ¼lmelidir.
  - Name
  - Type
  - Value

* Constant, Sabitler program boyunca deÄŸeri deÄŸiÅŸmeyen Ã¶zel bir deÄŸiÅŸken tÃ¼rÃ¼ olarak dÃ¼ÅŸÃ¼nÃ¼lebilir
1.5 - Veri Organizasyonu videosunu tekrar izle: sbyte ile byte organisazyonu tamamen farklÄ±. tÃ¼rlerin farklÄ±lÄ±klarÄ± ve ilgilendikleri deÄŸerler Ã¶nemli bellek Ã¼zerinde hesaplanmasÄ± ve organizasyonu




#Â Soyut Veri TÃ¼rÃ¼ (Abstract Data Type)
Stack (YÄ±ÄŸÄ±n) Ana iÅŸlevler
  push(T item)
  pop()
  peek()
  
Queue (Kuyruk) Ana Ä°ÅŸlevler
  enQueue(T item)
  deQueue()
  peek()

        * Angry Birds - Oyunda, KuÅŸlarÄ±n sÄ±ralÄ± ÅŸekilde atÄ±lmasÄ±





02. Algorithms Analysis and Asymptotic Notations
Algoritma iÃ§in 5 tane temel Ã¶zellik
- GiriÅŸi olmalÄ±
- Ã‡Ä±kÄ±ÅŸÄ± olmalÄ±
- Her adÄ±mdÄ± tanÄ±mlÄ± olmalÄ±
- SÄ±nÄ±rlÄ± sayÄ±da adÄ±mda olmalÄ±
- Etkililik (Zamansal/Uzaysal Analiz)


Time Complexity (Zaman KarmaÅŸÄ±klÄ±ÄŸÄ±) --> T(n)
  n = algoritmanÄ±n girdisi
        â€¢ Dizi (boyutu doÄŸrudan etki eder)
        â€¢ Polinom (polinom derecesi etki eder)
        â€¢ Matris (eleman sayÄ±sÄ± etki eder) --> 1 elemanlÄ± bir veriyle 100 elemanlÄ± bir veri farklÄ± zamanlarda Ã§alÄ±ÅŸÄ±r.
        â€¢ Ä°kilik veri (bit sayÄ±sÄ± etki eder)
        â€¢ Graf (kenar ve dÃ¼ÄŸÃ¼m sayÄ±sÄ± etki eder)

      â€¢ AlgoritmanÄ±n dayandÄ±ÄŸÄ± paradigma/yaklaÅŸÄ±m (Ã‡Ã¶zÃ¼m kÃ¼mesi)
            Backtracking
            Branch and bound
            Brute-force search
            Divide and conquer
            Dynamic programming
            Greedy algorithm
            Prune and search

* Bir problemi Ã§Ã¶zmenin farklÄ± yollarÄ± olabilir burda sÃ¶z konusu kullanÄ±lan strateji
      Ã–rneÄŸin rasgele bir sayÄ± dizisini Binary Search ile Ã§Ã¶zÃ¼mlemek
                                  ya da Sequential Search ile Ã§Ã¶zÃ¼mlemek
                                  
                                  Ã‡alÄ±ÅŸma SÃ¼resi: Hangisinin daha iyi olduÄŸu Ã¶nemli Ã§Ã¶zÃ¼m iÃ§in buradaki durum zaman karmaÅŸÄ±klÄ±ÄŸÄ±nda bize Ã§Ã¶zÃ¼me en hÄ±zlÄ± yola gitmek iÃ§in Ã¶nemli
                                  SÃ¼re zamanÄ± deÄŸil, iÅŸlem sayÄ±sÄ±nÄ± ifade eder
                                  
* GiriÅŸ boyutunun bÃ¼yÃ¼mesi: Growing Problem: Her zaman sonsuza giderken nasÄ±l bÃ¼yÃ¼dÃ¼ÄŸÃ¼nÃ¼ dÃ¼ÅŸÃ¼nmeliyiz
      Asimptotik Natasyonlar
        - Time Complexity (n)
        - Space Cost (n)
        - Space Complexity (n)
        
        


# Running Time Analysis - Ã‡alÄ±ÅŸma/YÃ¼rÃ¼tme ZamanÄ± Analizi

Bir AlgoritmanÄ±n YÃ¼rÃ¼tme ZamanÄ± Analizi (Running time analysis)

SORTED ARRAY | UNSORTED ARRAY
           7 | 8 | 2 | 4 | 6 | 3        unsorted arrayden bir eleman alÄ±nÄ±p sorted arraye uygun olan pozisyona yerleÅŸtirmek
            <- 5
Insertion Sort Algorithm Steps
01. SELECT THE FIRST UNSORTED ELEMENT
02. SWAP OTHER ELEMENTS TO THE RIGHT TO CREATE THE CORRECT POSITION AND SHIFT THE UNSORTED ELEMENT.
03. ADVANCE THE MARKER TO THE RIGHT ONE ELEMENT

Solution:
           2 | 3 | 4 | 5 | 6 | 7 | 8 

Pseudo Code: 8 SatÄ±rlÄ±k Kod                               Calculation
INSERTION-SORT(A)                   Cost  Times           (Her bir satÄ±rÄ±n maliyetini ve kaÃ§ kez Ã§alÄ±ÅŸacaÄŸÄ±nÄ± hesaplamak)
for j <- 2 to length[A]             C_1   n               c_1 * n
  do key <- A[j]                    C_2   n-1             c_2 * n-1
    â–· Insert A[j] into the sorted
             sequence A[1..j-1].    0     n-1             no cost
    i <- j - 1                      C_4   n-1             c_4 * n-1
    while i > 0 and A[i] > key      C_5   Î£n_j=2t_j
      do A[i+1] <- A[i]             C_6   Î£n_j=2(t_j-1)
        i <- i-1                    C_7   Î£n_j=2(t_j-1)
    A[i+1] <- key                   C_8   n-1
                                                         + Hepsi toplamÄ± bize yÃ¼rÃ¼tme zamanÄ±nÄ±n analizini verir.
                                                         T(n) elde edilir.

Kod Ã¼zerinden yÃ¼rÃ¼tme zaman analizine geÃ§ersek C#
Bir dÃ¶ngÃ¼nÃ¼n Ã§alÄ±ÅŸma zamanÄ± analizi
DÃ¶ngÃ¼ (Loop)                        Cost  Times
i = 1;                              c1    1
sum = 0;                            c2    1
while (i <= n) {                    c3    n+1
  i= i+ 1;                          c4    n
  sum = sum + i;                    c5    n
}
                                    Total Cost = c1 + c2 + (n+1) * c3 + n * c4 + n * c5
                                    Bu algoritmanÄ±n bÃ¼yÃ¼me hÄ±zÄ± n deÄŸeri ile orantÄ±lÄ±dÄ±r.

Code Example 01: Her bir satÄ±rÄ±n sabit maliyeti olduÄŸunu dÃ¼ÅŸÃ¼nelim ve C = 1 diyelim
int kareToplami(int N)
{
  int i, toplam = 0;              # Ä°ki tane deÄŸiÅŸken tanÄ±mlanmÄ±ÅŸ, tek bir tane ; var. Yani tek bir komutla bu iÅŸi yapÄ±yoruz bu sabit maliyetli ve 1 maliyete sahip
  for (i = 0; i < N; i++)         # i = 0 atama yapÄ±lmÄ±ÅŸ 1 birimlik iÅŸlem. i, 0dan baÅŸlar parametre olarak gelen n'e baÄŸlÄ± olarak Ã§alÄ±ÅŸÄ±yor, dolayÄ±sÄ±yla n kez dÃ¶ner, 1 kez de dÃ¶ngÃ¼nÃ¼n kÄ±rÄ±lma durumundaki karÅŸÄ±laÅŸtÄ±rma var n+1 oluyor. i++ ise n kez arttÄ±rÄ±m yapÄ±lacaÄŸÄ±nÄ± gÃ¶sterir n olur.  yani 2n+2 lik bir maliyete sahip 
  {
    toplam += i * i;              # for dÃ¶ngÃ¼sÃ¼ n kez Ã§alÄ±ÅŸacaÄŸÄ± iÃ§in maliyeti de n olacak
  }
  return toplam;                  # return ifadesi de 1 kez Ã§alÄ±ÅŸacak
}

Ä°lgili kod bloÄŸunu incelediÄŸimiz zaman: T(n) = 1 + 2n+2 + n + 1
                                        T(n) = 3n+5 olarak hesaplanÄ±r
                                        
                                        

Code Example 02: 
double OrtalamaHesapla(double[] A)
{
  double ortalama = 0, toplam = 0;
  for (int i = 0; i < A.Length; i++)
  {
    toplam + A[i];
  }
  ortalama = toplam /A.Length;
  return ortalama;

}


Code Example 03: KoÅŸul ifadesi iÃ§eren bir dÃ¶ngÃ¼nÃ¼n Ã§alÄ±ÅŸma zamanÄ± analizi
EÄŸer koÅŸul ifadesi iÃ§eren bir kod parÃ§acÄ±ÄŸÄ± var ise
                      Cost  Times
if (n < 0)            c1    1
  absval = -n         c2    1
else
  absval = n;         c3    1

Toplam Maliyet <= c1 + max(c2,c3)

# If bloklarÄ±nda, KoÅŸulun doÄŸru olmasÄ± durumunda bir blok Ã§alÄ±ÅŸÄ±r, olmazsa baÅŸka bir ifade Ã§alÄ±ÅŸÄ±p yoluna devam eder. Yani her ikisi de Ã§alÄ±ÅŸmaz.
  DoÄŸru olursa C2 diyelim, yanlÄ±ÅŸ ise C3 diyelim
  KoÅŸul ifadesi gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ yerde maximum karmaÅŸÄ±klÄ±k ifade edilir. max(c2,c3)
  Ä°ÅŸlem nerdeyse o dikkate alÄ±nÄ±r c2de ise c2 dikkate alÄ±nÄ±r deÄŸilse diÄŸeri dikkate alÄ±nÄ±r.





Code Example 04: ArdÄ±ÅŸÄ±k programlarÄ±n Ã§alÄ±ÅŸma zamanÄ± analizi
void kosulBloklari(int n)
{
  int toplam = 0;                     # 1
  if (n % 2 == 0)                     # Her hÃ¼lakarda 1 kez Ã§alÄ±ÅŸacak. 
    for (int i= 1; i <= n; i ++)      # 2n+2
      toplam += i * i;                # n
  else                                #Â doÄŸru olmamasÄ± durumuna bakarsak
      for (int i= 0; i< n; i ++)      # 2n+2
        for (int j = 0; j< n; j ++)   # j iÃ§in de 2n+2lik bir ifade var. iÃ§iÃ§e bir dÃ¶ngÃ¼ var. ilk for dÃ¶ngÃ¼sÃ¼ n kez dÃ¶ndÃ¼ÄŸÃ¼ iÃ§in Ã§arpan etkisi var. bu da (2n+2).n
          toplam += i;                # for yÃ¼zÃ¼nden n kez bir n de dÄ±ÅŸardaki ilk fordan gelir n2 (n kare) olur
  Console.WriteLine(toplam);          # 1
}

          T(n) = 1 + 1 + (2n+2) + 2nkare + 2n + nkare + 1
          T(n) = 3nkare + 4n + 5
  
  
  
  
Code Example 05: KoÅŸul ifadesi iÃ§eren bir dÃ¶ngÃ¼nÃ¼n Ã§alÄ±ÅŸma zamanÄ± analizi
double EnKucukBul(double[] A)
{
  double enKucuk = A[0];
  for (int i = 1; i < A.Length; i++)
  {
    if (A[i] < enKucuk)
      enKucuk = A[i];
  }
  return enkucuk;
}  




Code Example 06: Ä°Ã§ iÃ§e dÃ¶ngÃ¼nÃ¼n Ã§alÄ±ÅŸma zamanÄ± analizi
Ä°Ã§iÃ§e dÃ¶ngÃ¼ler
                                Maliyet   Defa
i=1;                            c1        1
sum = 0;                        c2        1
while (i <= n) {                c3        n+1         # DÄ±ÅŸtaki dÃ¶ngÃ¼ iÃ§teki satÄ±rlar Ã¼zerinde Ã§arpan etkisine sahip, dolayÄ±sÄ±yla 
  j=1;                          c4        n           # j=1 aslÄ±nda tek 1 maliyete sahip ama dÄ±ÅŸtaki dÃ¶ngÃ¼ n kez dÃ¶ndÃ¼ÄŸÃ¼ iÃ§in n olarak ifade edilir yani n*1=n
  while (j <= n) {              c5        n*(n+1)     # yukardaki yorumun devamÄ± olarak bu tarz bir ifadeyse karÅŸÄ±laÅŸÄ±lÄ±rsa ilk Ã¶nce iÃ§teki dÃ¶ngÃ¼ Ã§Ã¶zÃ¼mlenir. DÄ±ÅŸtaki dÃ¶ngÃ¼ kaÃ§ kez dÃ¶nÃ¼yorsa onu Ã§arpan olarak daÄŸÄ±tÄ±rÄ±z.
    sum = sum + i;              c6        n*n 
    j = j+ 1;                   c7        n*n         # buraya kadarki yani sÃ¼slÃ¼ paranteze kadarki tÃ¼m n ifadesi dÄ±ÅŸtaki dÃ¶ngÃ¼den geliyor.
  }
  i = i+1;                      c8        n           # normalde 1 kez Ã§alÄ±ÅŸÄ±r ama en yukardaki dÃ¶ngÃ¼den dolayÄ± n kez Ã§alÄ±ÅŸÄ±yor
}

Toplam Maliyet = c1 + c2 + (n+1)*c3 + n*c4 + n*(n+1)*c5 + n*n*c6 + n*n*c7 + n*c8
Bu algoritmanÄ±n Ã§alÄ±ÅŸma zamanÄ± nÂ² orantÄ±lÄ±dÄ±r.


Code Example 07: Ä°Ã§ iÃ§e dÃ¶ngÃ¼nÃ¼n Ã§alÄ±ÅŸma zamanÄ± analizi
int matrisElemanlarininToplami(int[,] A)
{
  int toplam = 0;                 1
  int n = A.GetLength(0);         1
  int m = A.GetLength(1);         1
  for (int i = 0; i < n; i++)     1 + n+1 + 1 = 2n+2    yani sÃ¼slÃ¼ parantezin iÃ§indekiler hesaba katÄ±larak oraya kadar n kez 
  {
    for (int j=0; j<m; j++)       1 + m+1 + m = 2m+2    burada dikkat edilmesi gereken ikinci bir deÄŸiÅŸken var m
    {                                          (2m+2)*n dÄ±ÅŸtaki for dÃ¼ngÃ¼sÃ¼ Ã§arpan etkisi yapÄ±ldÄ±
      toplam += A[i, j];          m*n                   bu satÄ±r da for dÃ¶ngÃ¼sÃ¼ne gÃ¶re m kez dÃ¶nmÃ¼ÅŸ olcak
    }
    return toplam;                1
}


T(n,m) = 3 + 2n+2 + n*(2m+2) + n*m + 1 = ?
T ifademiz sadece n'e deÄŸil m'e de baÄŸlÄ± T(n,m)





Code Example 08: ArdÄ±ÅŸÄ±k programlarÄ±n Ã§alÄ±ÅŸma zamanÄ± analizi
void ardisikProgramlama(int n)
{
  int toplam = 0;
  for (int i=1; i<=n; i++)
    toplam ++;

  for (int i=1; i<=n; i++)
    for (int j=1; j<n; j++)
      toplam ++;
  Console.WriteLine(toplam);
}


Code Example 09: DÃ¶ngÃ¼ sayÄ±sÄ±nÄ±n ardÄ±ÅŸÄ±k artmadÄ±ÄŸÄ± durumlarÄ± deÄŸerlendirme
#Â LogaritmalÄ± Ã¶rnek
void hesapla(int k)
{
  int sayac = 0;
  while (k>1)
  {
    saya++;
    k /= 2;
  }
  Console.WriteLine(sayac);
}



Code Example 10: Ã–zyinelemeli (rekÃ¼rsif) bir metodun Ã§alÄ±ÅŸma zamanÄ± analizi
int faktoriyel(int n)
{
  if(n <= 1)
    return 1;
  else
    return n * faktoriyel(n - 1);
}



2.5 Big-Oh Notasyon
Ã–rnek:
A ÅŸehrinden B ÅŸehrine nasÄ±l gidilir?
1. UÃ§ak       maliyeti 2 saat 1000lira
2. Tren       maliyeti 8 saat 500lira
3. Araba      maliyeti 4 saat 400lira
  SeÃ§enekler(Algoritmalar) Ã§oÄŸaltÄ±labilir - KarÅŸÄ±laÅŸtÄ±rma yapmak iÃ§in analiz etmemiz gerek

SÄ±ralama AlgoritmalarÄ±
- Insertion
- Selection
- Quicksort
- Binary
- Bubble

Big Oh amacÄ±: sabit faktÃ¶rleri ve dÃ¼ÅŸÃ¼k dereceli terimleri bastÄ±rarak bÃ¼yÃ¼k Ã¶lÃ§ekli giriÅŸler iÃ§in algoritmanÄ±n davranÄ±ÅŸÄ±nÄ± kodlayabilmek
AlgoritmalrÄ± Ã§alÄ±ÅŸma zamanÄ±na gÃ¶re sÄ±nÄ±flayabilmek.

Big-Oh
|f(n)| â‰¤ c * |g(n)|, tÃ¼m n â‰¥ nã€‚
"Pozitif tam sayÄ±lardan pozitif tam sayÄ±lara kadar 
      f(n) ve g(n) monotonik(sÃ¼rekli artan) fonksiyonlar iÃ§in 
        c > 0 (sabit deÄŸer 0dan bÃ¼yÃ¼k olacak) ve nã€‚> 0 (giriÅŸ deÄŸeri 0dan bÃ¼yÃ¼k olacak) sabitleri olduÄŸunda f(n) = 0(g(n)) ÅŸekliden temsil ifade edilir."
          ve n â‰¥ nã€‚(n, nã€‚'dan bÃ¼yÃ¼k olacak)

"Sezgisel olarak, bu f(n) fonksiyonunun g(n)'den daha hÄ±zlÄ± bÃ¼yÃ¼mediÄŸi
  veya g(n) fonksiyonunun f(n) iÃ§in, yeterince bÃ¼yÃ¼k olan n â†’â†’ âˆ iÃ§in bir Ã¼st sÄ±nÄ±r olduÄŸu anlamÄ±na gelir."


Ä°ki tane fonksiyon ver.
f(n) = 50.n
g(n) = nÂ²
  
|f(n)| â‰¤ c * |g(n)|  
 f(n) â‰¤ c * g(n)      --> mutlak deÄŸerden kurtardÄ±k


n       f(n)=50.n       g(n)=nÂ²
------------------------------
1       50              1
10      500             100       500 adÄ±mda Ã§Ã¶zÃ¼yor halen g(n), f(n)den verimli
100     5000            10000     iÅŸler deÄŸiÅŸti, g(n) daha maliyetli hale geldi, daha hÄ±zlÄ± bÃ¼yÃ¼dÃ¼. n>nã€‚
1000
....
....
 âˆ 

Big oh ile en kÃ¶tÃ¼ durum analizi yapÄ±lÄ±r

Ã‡alÄ±ÅŸma ZamanÄ± Analizi
- Ã‡alÄ±ÅŸma zamanÄ± giriÅŸ boyutunun boyutuna baÄŸlÄ± olarak artar.
- GiriÅŸ boyutu n'e baÄŸlÄ± olarak varsayÄ±m yapÄ±lmamalÄ±dÄ±r.
- n her zaman kÃ¼Ã§Ã¼k olmayabilir. g(n) belli bir yerden sonra f(n)i geÃ§ti



Ã‡alÄ±ÅŸma ZamanÄ± Analizi
- BÃ¼yÃ¼me HÄ±zÄ± (Rate of Growth): Girdinin bir fonksiyonu olarak Ã§alÄ±ÅŸma sÃ¼resinin artma hÄ±zÄ±. BÃ¼yÃ¼me hÄ±zÄ±nÄ± dikkate al
- Alt SÄ±radan Terimler (Lower Order Terms): Bir fonksiyonun bÃ¼yÃ¼me oranÄ±na iliÅŸkin bir tahmin verildiÄŸinde, 
    daha yÃ¼ksek dereceli ÅŸartlar iÃ§in daha az Ã¶nemli olduklarÄ±ndan, 
      dÃ¼ÅŸÃ¼k dereceden terimleri dÃ¼ÅŸÃ¼rme eÄŸilimindeyiz.
          f(n) = nÂ³ + 5n + 3    --->   O(nÂ³).      ---> 5n ve 3 deÄŸerini dikkate almamak/dÃ¼ÅŸÃ¼rmek daha iyi
      Daha dÃ¼ÅŸÃ¼k deÄŸere sahip terimleri dikkate almamak gerek.
      n kÃ¼p bÃ¼yÃ¼meye etsiki olan en baskÄ±n deÄŸer
      



Big oh Notasyonu uygulamalarÄ±


Ã–lÃ§Ã¼m TÃ¼rleri
- Worst Case (En kÃ¶tÃ¼ durum)    big-oh
- Best Case (en iyi durum)      omega
- Average Case (ortalama durum) tetha

Big-Oh Genel Kurallar
1. Sabitler ihmal edilir (constant factor). Daha dÃ¼ÅŸÃ¼k terimler atÄ±labilir.
    T(n) = 5n + 3     => O(n)
    T(n) = 10n + 99   => O(n)
    T(n) = 1000n      => O(n)
2. BaskÄ±n terim dikkate alÄ±nÄ±r.
    O(1) < 0(logn) < O(n)         O(1) --> sabit zamanlÄ± bir ifade, 0(logn) --> logaritmik zamanlÄ± bir ifade, O(n) --> doÄŸrusal zamanlÄ± bir ifade
    O(nÂ²+5n+100) => 0(nÂ²)

      nÂ² --> sanki iki tane iÃ§iÃ§e for dÃ¶ngÃ¼sÃ¼ var gibi dÃ¼ÅŸÃ¼n
      5n --> sadece bir for dÃ¶ngÃ¼sÃ¼ var gibi dÃ¼ÅŸÃ¼n
      100 --> sabit iÅŸlemler var gibi dÃ¼ÅŸÃ¼n

Examples:
Fonksiyon                   Big O (En baskÄ±n karakterleri yaz)
----------------------------------
n^4 + 100nÂ² + 10n + 50      O(n^4)
10nÂ³ + 2nÂ²                  O(nÂ³)
nÂ³-nÂ²                       O(nÂ³)
10                          0(1)        Sabit zamanlÄ±ysa her zaman 1 olur
1273                        0(1)




Example:
f(x) = xÂ² + 2x+1 is O(xÂ²)
  Ä°stediÄŸimiz ÅŸey --> f(x) <= cg(n)
Ã‡Ã¶zÃ¼m: 
  xÂ² + 2x+1 â‰¤ xÂ² + 2xÂ² + xÂ²
  xÂ² + 2x+1 â‰¤ 4.xÂ²
  c = 4 olur
  
  Bu ise big-Oh notasyonu kapsamÄ±nda --> f(x) = O(g(n))
                                              = O(xÂ²)
                                              
  
Example:  
f(x) = xÂ² + 2x+1 is 0(xÂ²)
xÂ² + 2x+1 â‰¤ CxÂ² when x > k
Solution:
0 â‰¤ xÂ² + 2x+1 â‰¤ xÂ² + 2xÂ² + xÂ² = 4xÂ²
  
Example:
  ilk versiyon:   f(x) = xÂ² + 2x+1 is 0(xÂ²)
  ikinci version: xÂ² + 2x+1 is 0(xÂ³)        Maliyeti daha fazla olur kÃ¼p yÃ¼zÃ¼nden.
  Bu yÃ¼zden ilk versiyonu tercih ederiz.
  
Example:
n! ifadesinin O(n") olduÄŸunu gÃ¶sterelim. (n^n)
:. n! â‰¤ C.n" bazÄ± n>k                         n! - n'e kadar gider
:. 1.2.3. ... .n â‰¤ n.n.n. ... .n  = f(x) = O(g(n)) = O(n^n)
C=1 ve k=1 olduÄŸunda n!= O(n")


Example:
f(n) = nÂ² , O(n) olmaz!!!

:. nÂ² â‰¤ C.n for some n>k
:. nÂ² / n â‰¤ C.n / n
:. n â‰¤ C
  Burada n deÄŸiÅŸkendir ve C ise bu sabittir.
  DoÄŸrusal deÄŸildir.


Example:
EÄŸer fâ‚(n) -> O(gâ‚(n)) and fâ‚‚(n)-> O(gâ‚‚(n)) ise
f(n) * fâ‚‚(n) is O(gâ‚(n) * gâ‚‚(n))


Example: (3n+1)*(2n+log n) ilgili Ã¶rneÄŸin derecesi nedir?
          3n+1              -> O(n)
                 2n+log n   -> O(n)
         (3n+1)*(2n+log n)  -> O(n*n)=O(nÂ²)



n-GiriÅŸ boyutu: KarmaÅŸÄ±klÄ±ÄŸÄ±nÄ± kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe doÄŸru sÄ±ralanmasÄ±. (SÄ±k kullanÄ±lan fonksiyonlar)
    Sabit Zaman: 0(1)                     En iyi durum (Girdi ne kadar bÃ¼yÃ¼rse bÃ¼yÃ¼sÃ¼n deÄŸiÅŸmediÄŸi iÃ§in)
    Logaritmik Zaman: O(log(n))
    DoÄŸrusal Zaman: O(n)
    DoÄŸrusal-logaritmik Zaman: O(n log(n))
    Ä°kinci Dereceden Zaman: O(nÂ²)         Karesel ifadelerde bÃ¼yÃ¼me artar.
    Kubik Zaman: O(nÂ³)
    Ãœstel Zaman: 0(b^n)                   b>1
    Faktorivel Zaman: O(n!)               En kÃ¶tÃ¼ durum

    Operations and Elements Graph



AlgoritmanÄ±n Zaman KarmaÅŸÄ±klÄ±ÄŸÄ±

                                        n
         ------------------------------------------------------------------
Function  10    100       1,000     10,000     100,000      1,000,000
---------------------------------------------------------------------------
1         1     1         1         1          1            1
logâ‚‚n     3     6         9         13         16           19
n         10    10Â²       10Â³       10^4       10^5         10^6
n *logâ‚‚n  30    664       9,965     10^5       10^6         10^7
nÂ²        10Â²   10^4      10^6      10^8       10^10        10^12
nÂ³        10Â³   10^6      10â¹       10^12      10^15        10^18
2^n       10Â³   10^30     10^301    10^3,010   10^30,103    10^301,030


FarklÄ± veri yapÄ±larÄ±nÄ± ve iÅŸlemlerini/fonksiyonlarÄ±nÄ± karÅŸÄ±laÅŸtÄ±rmak iÃ§in big-oh notasyonunu kullandÄ±k.
Ä°lgi ifadeyi f(n)'i big-oh ile ifade edebilmek iÃ§in bir C sabitine, bir de g(n) fonksiyonuna ihtiyacÄ±mÄ±z olur.
Ã–yle bir nokta aradÄ±k ki bu noktadan sonra f(n) fonksiyonu, cg(n) fonksiyonuyla sÄ±nÄ±rlamasÄ±nÄ± saÄŸlamak gerekli grafikte de gÃ¶sterildiÄŸi gibi. o nokta ise nã€‚noktasÄ±.
  Bu durumda da en kÃ¶tÃ¼ durumu konuÅŸmuÅŸ oluyoruz. bunu da O notasyonunda gÃ¶steriyoruz


# OH notasyonu O             f(n) = O(g(n))
O(g(n))=
{
  f(n):
  Æ pozitif sabitler c and nã€‚,
  âˆ€ n â‰¥ nã€‚,
  0 â‰¤ f(n) â‰¤ cg(n)
}


DiÄŸer Notasyonlara gelirsek;

# THETA notasyonu Î¸             f(n) = Î¸(g(n))
Î¸(g(n))=
{
  f(n):
  Æ pozitif sabitler Câ‚,Câ‚‚,ve nã€‚,
  âˆ€ n â‰¥ nã€‚,
  0 â‰¤ câ‚g(n) â‰¤ f(n) â‰¤ câ‚‚g(n)
}


# OMEGA notasyonu Î©             f(n) = Î©(g(n))    (Grafikte O notasyonun tersi olarak gÃ¶zÃ¼kÃ¼r.)
Î©(g(n))=
{
  f(n):
  Æ pozitif sabitler c and nã€‚,
  âˆ€ n â‰¥ nã€‚,
  0 â‰¤ cg(n) â‰¤ f(n)
}



# Small oh - o notasyonu
o(g(n))=
{
  f(n): âˆ€ c>0, Æ nã€‚>0
  âˆ€ n â‰¥ nã€‚,
  0 â‰¤ f(n) < cg(n)
}

      g(n) Ã¼st sÄ±nÄ±rÄ± f(n) iÃ§in asimptotik olarak sÄ±kÄ± deÄŸildir.



# Small Omega - w notasyonu               (to represent whole numbers. Whole numbers are counting numbers from 0 to infinity)
o(g(n))=
{
  f(n): âˆ€ c>0, Æ nã€‚>0
  âˆ€ n â‰¥ nã€‚,
  0 â‰¤ f(n) < cg(n)
}

      g(n) alt sÄ±nÄ±rÄ± f(n) iÃ§in asimptotik olarak sÄ±kÄ± deÄŸildir.




FonksiyonlarÄ±n KarÅŸÄ±laÅŸtÄ±rÄ±lmasÄ±
f <-> g = a <-> b

f(n) = O (g(n)) â‰ˆ a â‰¤ b       worst case
f(n) = Î© (g(n)) â‰ˆ a â‰¥ b       best case
f(n) = Î¸ (g(n)) â‰ˆ a = b       average case
f(n) = o (g(n)) â‰ˆ a < b
f(n) = w (g(n)) â‰ˆ a > b



Monotonluk (Bir fonksiyon ne zman artar/azalÄ±r)
â€¢ f(n)fonksiyonu:
  â€¢ Monoton artandÄ±r:     eÄŸer m â‰¤ n â‡’ f(m)â‰¤f(n)
  â€¢ Monoton azalandÄ±r:    eÄŸer m â‰¥ n â‡’ f(m)â‰¥f(n)
  â€¢ Kesinlikle artandÄ±r:  eÄŸer m < n â‡’ f(m)<f(n)
  â€¢ Kesinlikle azalandÄ±r: eÄŸer m > n â‡’ f(m)>f(n)

  Bu iÅŸlemler LÄ°MÄ°T konusuna baÄŸlÄ± olarak gerÃ§ekleÅŸtirilir







YENÄ° KONU
Asymptotic Analysis (Kod Ã¼zerinde analiz)
# loops (dÃ¶ngÃ¼ler)
n = 10                                        Sabit 1 maliyeti var
for i in range(0,n):                          Bu satÄ±rda Ã§evrim var, Ã§evrim n'e gÃ¶re Ã§alÄ±ÅŸÄ±yor
  print('Current number: + str(i))

   Total_time = a constant cx n = cn = 0(n)

    Bu algonun bÃ¼yÃ¼mesindeki faktÃ¶r doÄŸrudan n'dir. O(c.n) = O(n) olarak ifade edilebilir.
    


# nested loops (iÃ§iÃ§e dÃ¶ngÃ¼ler)
# outloop executed n times
n = 10
for i in range(0,n):                          dÄ±ÅŸtaki dÃ¶ngÃ¼ n'e baÄŸlÄ± olarak Ã§alÄ±ÅŸÄ±yor
  print('Current number: ' + str(i))
  for j in range(0,n):                        iÃ§teki dÃ¶ngÃ¼ de n'e baÄŸlÄ± olarak Ã§alÄ±ÅŸÄ±yor
    print('Current number: ' + str(i) + ',' + str(j))
                                              dÄ±ÅŸtaki dÃ¶ngÃ¼nÃ¼n iÃ§teki dÃ¶ngÃ¼ Ã¼zerinde Ã§arpan etki olduÄŸundan dolayÄ± baskÄ±n terim O(nÂ²) olduÄŸunu sÃ¶yleriz.
    Total_time = cx n x n = 0(nÂ²)             yani karesel bir Ã§alÄ±ÅŸma zamanÄ±na sahip olduÄŸunu sÃ¶yleyebiliriz.



# Consecutive statements (ArdÄ±ÅŸÄ±l bir ifade Ã¼zerinde analiz)  
for i in range(0,n):
  print('Current number: ' + str(i))          dÄ±ÅŸtaki n'e baÄŸlÄ± Ã§alÄ±ÅŸÄ±yor

for i in range(0,n):
  print('Current number: ' + str(i))
  
  for j in range(0,n):                        dÄ±ÅŸtaki dÃ¶ngÃ¼nÃ¼n iÃ§teki dÃ¶ngÃ¼ Ã¼zerinde Ã§arpan etki olduÄŸundan dolayÄ± baskÄ±n terim O(nÂ²)
    print('Current number: ' + str(i) + ',' + str(j))

  Total_time = cã€‚+ câ‚n + câ‚‚nÂ² = 0(nÂ²)         O(nÂ²+n) ama baskÄ±n olan ifade alÄ±nÄ±r bu yÃ¼zden O(nÂ²)



# Logarithmic complexity
def Logarithms(n):              log(2^k) = logn
  i=1
  while i<=n:                   klog2 = logn
    i= i*2
    print(i)                    k=n

Logarithms(100)                 Total_time = 0(logn)



Bir fonksiyon tanÄ±mÄ± yapÄ±lÄ±p n'i parametre olarak almÄ±ÅŸ
While dÃ¶ngÃ¼sÃ¼yle n'e baÄŸlÄ± olarak bir Ã§evrim gerÃ§ekleÅŸiyor. O(n) denilebilirdi ama farklÄ±lÄ±k ÅŸu ki 
i (sayaÃ§ deÄŸeri) iÃ§in her defasÄ±nda 2 ile Ã§arpÄ±lÄ±yor yani 2 katÄ± ÅŸeklinde ilerliyor (birer birer artmÄ±yor)
her defasÄ±nda 2 kat bÃ¼yÃ¼yor. 1 iken 2, 2 iken 4 bÃ¶yle sÃ¼rÃ¼p gidecek
bÃ¶yle bir dÃ¶ngÃ¼yle karÅŸÄ±laÅŸtÄ±ÄŸÄ±mÄ±zda bu dÃ¶ngÃ¼ye K deriz. bunun anlamÄ± dÃ¶ngÃ¼ logaritmik bir Ã§alÄ±ÅŸma zamanÄ±na sahip
mesela n deÄŸerini 16 olarak verdiÄŸimizi dÃ¼ÅŸÃ¼nÃ¼rsek 1den 16ya kadar 2 katÄ± ile sayar. 32ye geldiÄŸinde 32<=16 hayÄ±r deÄŸil, dÃ¶ngÃ¼ burda durur.
yani n 16 olduÄŸunda 5 adÄ±mda bunu bitirmiÅŸ oldu.
Bir problem ikiye bÃ¶lÃ¼nebiliyorsa bu durumda logaritmik ifadelerle karÅŸÄ±laÅŸÄ±lÄ±r.





YENÄ° KONU
RECURSION (Ã–ZYÄ°NELEMELÄ° Ä°FADELER)
  - Kendini Ã§aÄŸÄ±ran herhangi bir fonksiyon rekÃ¼rsif (recursive) olarak adlandÄ±rÄ±lÄ±r.
  - Ã–zyinelemeli bir yÃ¶ntem, daha kÃ¼Ã§Ã¼k bir sorun Ã¼zerinde Ã§alÄ±ÅŸmak iÃ§in kendisinin bir kopyasÄ±nÄ± Ã§aÄŸÄ±rarak bir sorunu Ã§Ã¶zer. 
    Bu rekÃ¼rsif adÄ±m (recursion step) olarak tanÄ±mlanÄ±r.
  - RekÃ¼rsif adÄ±m Ã§ok daha fazla rekÃ¼rsif Ã§aÄŸrÄ± ile sonuÃ§lanÄ±r.
  - Base Case (Temel Durum) ulaÅŸtÄ±ÄŸÄ± an durur.
  
  - Durma koÅŸulu olmalÄ±dÄ±r.
  - KÃ¼Ã§Ã¼k problemlerin daha kÃ¼Ã§Ã¼k dizileri temel duruma(base case) yakÄ±nsamalÄ±dÄ±r.
  - Ã‡oÄŸu zaman iteratif kod yazmaktan daha kÄ±sa ve kolaydÄ±r.
  - Benzer alt gÃ¶revlerin kullanÄ±mÄ±nda daha kullanÄ±ÅŸlÄ± olurlar. 
    SÄ±ralama, arama ve gezinme problemleri bu duruma Ã¶rnek olarak gÃ¶sterilebilir.


Ã–zyinelemeli FonksiyonlarÄ±n FormatÄ± (Format of Recursive Function)
Pseudo Code:
if(test for the base case)
  return some base case value
else if(test for another base case)
  return some another base case value
else
  return (some work and then a recursive call)
#
KoÅŸul ifadesi temel durumu ifade ediyor. Bu temel durumlar birden fazla olabilir.
FaktÃ¶riyel hesaplamasÄ±, recursive function'u anlamak iÃ§in ideal bir Ã¶rnek
5! = 5*4*3*2*1
Burda bir yakÄ±nsama sÃ¶z konusu, n deÄŸeri 1 deÄŸerine doÄŸru gitmek istiyor.


n! = (1         n â‰¤ 1)
     (n.(n-1)!  n > 1)

            5!                                Her defasÄ±nda n-1 olarak Ã§aÄŸÄ±rÄ±lÄ±yor
Start   ->  5*4!             4!
  120   <-  First Step   ->  4*3!              3!
                    24   <-  Second Step   ->  3*2!             2!
                                       6   <-  Third Step   ->  2*1!
                                                        2   <-  Fourth Step   ->  1
                                                                          1   <-  Sixth Step




DiÄŸer bir Ã¶rneÄŸini Fibonacci Serisinde GÃ¶rebiliriz.
Fibonacci Series 
f_n = f(n) = (0               n = 0)
             (1               n = 1)
             (f(n-1)+f(n-2)   n > 1)

FormÃ¼ldeki n deÄŸeri indexleri temsil ediyor.
           n deÄŸeri 2 ise = f(1) + f(0) toplamÄ± ÅŸeklinde dÃ¼ÅŸÃ¼nmeliyiz

Index       0   1   2   3   4   5   6   7     ...
-------------------------------------------------
Value       0   1   1   2   3   5   8   13    ...

                            f(1) + f(2)       next value
                              1  +   1    =   2
                          
                          Main Solution:  
                          f(2-1) + f(3-2) =   1 + 1 = 2 is 3th index value



DiÄŸer bir Ã¶rneÄŸini PermÃ¼tasyonda GÃ¶rebiliriz.
P(n,r) = (n  )  = n! / (n-r)!
         (n-r) 

PermÃ¼tasyon({a,b,c}) ise;
          1.   a PermÃ¼tasyon({b,c})
          1.1. b PermÃ¼tasyon({c})â†’ abc
          1.2. c PermÃ¼tasyon({b})â†’ acb
          
          2.   b PermÃ¼tasyon({a,c})
          2.1. a PermÃ¼tasyon({c})â†’ bac
          2.2. c PermÃ¼tasyon({a})â†’ bca
          
          3.   c Permutasyon({a,b})
          3.1. a PermÃ¼tasyon({b})â†’ cab
          3.2. b PermÃ¼tasyon({a})â†’ cha


Ä°ki yaklaÅŸÄ±m arasÄ±ndaki farklar
Ã–zyineleme  vs  Ä°terasyon
- Temel durum (base case) ulaÅŸÄ±nca durur.
                - Bir koÅŸulun yanlÄ±ÅŸ olmasÄ± durumunda durur.
- Her rekÃ¼rsif Ã§aÄŸrÄ± ekstra bellek alanÄ± kullanÄ±r.
                - Her bir iterasyon ekstra bellek gerektirmez.
- EÄŸer sonsuz rekÃ¼rsif Ã§aÄŸrÄ± yapÄ±lÄ±rsa; bellek taÅŸma hatasÄ± alÄ±nÄ±r  (stack overflow).
                - Ekstra bellek alanÄ± gerektirmediÄŸinden sonsuz dÃ¶ngÃ¼ler sonsuza kadar devam eder.
- BazÄ± problemlerin Ã§Ã¶zÃ¼mÃ¼ rekÃ¼rsif olarak daha kolay ifade edilebilir.
                - Iteratif Ã§Ã¶zÃ¼mler rekÃ¼rsif Ã§Ã¶zÃ¼mler kadar aÃ§Ä±k olmayabilir.



Ã–zyineleme iÃ§in Notlar
- RekÃ¼rsif algoritmalar iki durum iÃ§ermelidir.
  â€¢ RekÃ¼rsif durumlar ve temel durum. (temel durum da birden fazla olabilir, fibonacci serisi gibi)
- Her rekÃ¼rsif fonksiyon durumu temel durumda durmalÄ±dÄ±r, aksi durumda devam etmeli ama sonsuz olmamalÄ±.
- Genellikle iteratif Ã§Ã¶zÃ¼mler rekÃ¼rsif Ã§Ã¶zÃ¼mlerden daha verimlidir.
  â€¢ Ã‡Ã¼nkÃ¼ ekstra bellek alanÄ± kullanmazlar. Verim dÃ¼ÅŸÃ¼k olur. Ek olarak kuyruk oluÅŸur bu da bellek alanÄ± iÃ§in iyi deÄŸil.
- BazÄ± problemler en iyi rekÃ¼rsif Ã§Ã¶zÃ¼mler ile Ã§Ã¶zÃ¼lebilirken bazÄ±larÄ± iÃ§in durum tam tersi olabilir.



YENÄ° KONU
Ã–zyinelemeli Ã‡aÄŸrÄ±lar (Example Algorithms of Recursion)
â€¢ Fibonacci series
â€¢ Factorial finding
â€¢ Merge sort,quick sort
â€¢ Binary search
â€¢ Tree traversals and many tree problems:InOrder, PreOrder, PostOrder dolaÅŸÄ±mlar
â€¢ Graph Traversals:DFS,BFS. (Derinlik ve GeniÅŸlik odaklÄ± aramalar)
â€¢ Dynamic Programming Examples
â€¢ Divide and Conquer Algorithms
â€¢ Towers of Hanoi
â€¢ Backtracking algorithms (Geriye doÄŸru izleme)



YENÄ° KONU
Ã–ZYÄ°NELEMELÄ° ALGORÄ°TMALARIN ANALÄ°ZÄ° NASIL YAPILIR?
YERÄ°NE KOYMA METODU
Example: T(n) = T(n/2)+c,
         T(1) = 1 ve n => 2 koÅŸuluna uygun olarak ilgili yinelemenin Ã§Ã¶zÃ¼mÃ¼nÃ¼ yerine koyma metodu (substition) ile Ã§Ã¶zÃ¼nÃ¼z.


          T(n) = T(n/2)+c
                 Problem bu kÄ±sÄ±mda iki parÃ§aya bÃ¶lÃ¼ndÃ¼.
                 Bu ifadeyi T(2) iÃ§in yazarsak:
          T(2) = T(1)+c
                   1 +c     (T(1) ifadesinin 1'e karÅŸÄ±lÄ±k geldiÄŸini bilindiÄŸinden 1+c olarak yazÄ±labilir)    
   
                  Her defasÄ±nda problemin ikiye bÃ¶lÃ¼nebildiÄŸini biliyoruz. Bu yÃ¼zden;
          T(4) = T(2)+c
                 (1+c)+c    T(2) ifadesinin ne olduÄŸunu biliyoruz
                  1+2c
                  
          Bir adÄ±m daha ilerleyelim.
          T(8) = T(4)+c
                 (1+2c)+c
                  1+3c
          Bu ÅŸekilde artÄ±k problem kaÃ§ adÄ±m devam ediyorsa devam edilir. yani 2^k'ya kadar gitmiÅŸ olacak.
          
          AslÄ±nda T(2) = 2^1, T(4) = 2Â², T(4) = 2Â³
          

                      Bu k aslÄ±nda yukardaki iÅŸlemlere baÄŸlÄ± olarak Ã§arpan olarak geliyor.
          T(2^k) = 1+k.c olarak yazabiliriz.
          
                      Burdaki k ifadesini n cinsinden yazmak durumunda kalÄ±rÄ±z, amacÄ±mÄ±z T(n) ÅŸeklinde bir ifade.
                      2^k = n tanÄ±mÄ± yaparÄ±z.
                      Ä°kilik tabanlÄ± bir iÅŸlem olduÄŸu iÃ§in logaritmaya giriÅŸ yapÄ±lÄ±r
                      log_2 2^k ifadesi ortaya Ã§Ä±kar bu da aynÄ± ÅŸekilde log_2 n ÅŸeklinde ifadeye eÅŸittir.
                      bunun sonucu olarak k baÅŸa Ã§ekilir bu da k = log_2 n ÅŸeklinde yazÄ±lÄ±r.
                      
                      
          T(n) = 1 + logn.c           sabitler 1 ve katsayÄ±lar c gider, bu ifade sadece O(logn) ÅŸeklinde ifade edilebilir. 
                                      bunun anlamÄ± problemin logn zamanÄ±nda Ã§Ã¶zÃ¼lebilineceÄŸi anlamÄ±na gelir.
                      
          
          
          
ÃœÃ§ tane temel yaklaÅŸÄ±m vardÄ±r;
    - Substition yaklaÅŸÄ±mÄ±
    - Iteration yaklaÅŸÄ±mÄ±
    - Master teorem yaklaÅŸÄ±mÄ±
    
    
    
YENÄ° KONU
ITERASYON YÃ–NTEMÄ°
Example: T(n) = 2T(n/2)+n, n>1, T(1)=1 iÃ§in iterasyon yÃ¶ntemiyle Ã§Ã¶zÃ¼nÃ¼z. 

Temel iterasyon
      T(n) = 2T(n/2)+n


Birinci iterasyonda
      T(n/2) = 2T(n/4)+n/2
      
      BÃ¶ylece:
      T(n) = 2(2T(n/4)+(n/2))+n
      T(n) = 2Â²T(n/4)+2n

Bir iterasyon daha ilerletirsek
      T(n/4) = 2T(n/8)+n/4
      
      Her bir iterasyonda bir Ã¶ncekinin T(n/..) kullanÄ±lÄ±r
      BÃ¶ylece:
      T(n) = 2Â²(2T(n/8)+(n/4))+2n
      T(n) = 2Â³.T(n/8)+3n      

      Her defasÄ±nda T(n) hesaplanÄ±yor yani.

      Bu ifade k adÄ±mda ilerlediÄŸini dÃ¼ÅŸÃ¼ndÃ¼ÄŸÃ¼mÃ¼zde;
      T(n) = 2^k.T(n/2^k)+k.n
      
      k ifadesini n cinsinden yazmamÄ±z gerekli
        uygun sonucun bizi 1'e gÃ¶tÃ¼rdÃ¼ÄŸÃ¼nÃ¼ biliyoruz (T(1)=1)
      n/2^k = 1       --> n = 2^k
      
      log_2 n = log_2 2^k
      
      logn = k
      
      T(n) = 2^k.T(n/2^k)+kn
      
             2^k n'e eÅŸit olacak
           = n.T(1)+logn.n
           = n + nlogn
           = nlogn          ortalama durum. bu problem Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ± zaman nlogn gibi bir zman karmaÅŸÄ±klÄ±ÄŸÄ±nda Ã§Ã¶zÃ¼mlenmiÅŸ olacak
           
           
YENÄ° KONU
ANA TEOREM (MASTER TEOREM)
BÃ¶l ve YÃ¶net yaklaÅŸÄ±mÄ± iÃ§in ana teorem konusu
bu yaklaÅŸÄ±mÄ± merge sort, binary sort, quick sort gibi algolarda gÃ¶rebiliriz

Ã–rnek olarak elimizde bir dizi olduÄŸunu varsayarsak,
# A dizinin baÅŸlangÄ±Ã§ indexi i, bitiÅŸ indexi j ve n tane elemandan oluÅŸuyor
Dizi Ã¼zerinde rasgele elemanlar var ve bunlar iÃ§in sÄ±ralama iÅŸlemi yapalÄ±m
quick sort kullanalÄ±m, algo parametre olarak bizden bir dizi isteyecek, baÅŸlangÄ±Ã§ ve bitiÅŸ indexi isteyeck
qs(A,i, j)
    partitiion index olacak (bÃ¶lÃ¼tleme - diziyi iki parÃ§aya ayÄ±rÄ±caz)
          pi = partition(A, i, j) --> yine parametreleri bizden isteyecek
    dizi iÃ§inde de bi pivot elemanÄ±mÄ±z olacak.
    pivot ile diÄŸer elemanlarÄ± kÄ±yaslayacak - pivottan kÃ¼Ã§Ã¼k elemanlarÄ± sola, bÃ¼yÃ¼k elemanlarÄ± saÄŸa alacak    
    pivota bir nevi partition index'i diyebiliriz.
    quick sortu tekrar Ã§alÄ±ÅŸtÄ±rÄ±rÄ±z.
      QS(A, i, pi-1)   ---> sol tarafÄ± dikkat ederiz yani daha kÃ¼Ã§Ã¼k bir parÃ§a Ã¼zerinde aynÄ± algoyu tekrar Ã§alÄ±ÅŸtÄ±rÄ±rÄ±z   
      QS(A, pi+1, j)      ---> bu sefer saÄŸ tarafÄ± dikkate alÄ±rÄ±z. ve j'ye kadar Ã§alÄ±ÅŸtÄ±rÄ±rÄ±z

      Peki ya analizi
          pi = partition(a, i ,j) ---> n adÄ±ndaki arrayin tÃ¼m elemanlarÄ±nÄ± iÃ§erdiÄŸi iÃ§in n kadar maliyetlidir.
                                  ---> tetha(n)
          QS(A, i, pi-1)          ---> T(n/b)   --> her bir ifade b olarak kabul edilir. yani b parÃ§aya ayÄ±rdÄ±ÄŸÄ±nÄ± dÃ¼ÅŸÃ¼nÃ¼rsek. uzunluk olarak
          QS(A, pi+1, j)          ---> T(n/b) 

          T(n) = T(n/b)+ T(n/b) + tetha(n)
          T(n) = 2.T(n/b) + tetha(n)

          Bu ifadenin sÃ¶ylediÄŸi ben 2.T(n/b) zamanÄ±nda Ã§alÄ±ÅŸÄ±rÄ±m. ve ek bir yÃ¼ke sahibim bunu da f(n) ya da tetha(n) ile ifade ederim.
          burda iki b var bunun anlamÄ± dizi iki parÃ§aya bÃ¶lÃ¼nmÃ¼ÅŸ demek
          Åimdi master teorem burda ne iÅŸimize yarayacak.
          genel bir formÃ¼lle yazarsak
          T(n) = a.T(n/b)+tetha(n)
          big oh notasyonu ne isterdi? - BaskÄ±n olan ifadeyi bulun.
                 a.T(n/b) + tetha(n)
                 --------   --------
                     a          b
                     
                 bakÄ±lacak durumlar baskÄ±n ifadeyi bulmak iÃ§in, Ã§Ã¼nkÃ¼ big oh'da o terim dikkate alÄ±nacak.
                 1. durum -> a>b       a bÃ¼yÃ¼k mÃ¼?
                 2. durum -> a==b      a ile b arasÄ±nda eÅŸitlik var mÄ±?
                 3. durum -> a<b       a kÃ¼Ã§Ã¼k mÃ¼?
                 
                 
                a kÄ±smÄ± n^logb tabanÄ±nda a ÅŸeklinde yazarÄ±z
                b kÄ±smÄ± da f(n) ile ifade edeceÄŸiz
                bu iki ifade karÅŸÄ±laÅŸtÄ±rÄ±larak master teorem Ã¼zerinden Ã§Ã¶zÃ¼me gidilecek.
                
                eÄŸer ilk durumdaki gibi a bden bÃ¼yÃ¼k ise baskÄ±n terim t(n/b) karmaÅŸÄ±klÄ±k buna gÃ¶re hesaplanÄ±r.
          T(n) =     tetha(n^logb tabanÄ±nda a) + f(n) = tetha(n^log b tabanÄ±nda a - epsilon)
                eÄŸer ikinci durum yani eÅŸitlik sÃ¶z konusu olduÄŸunda
          T(n) =     tetha(n^log b tabanÄ±nda a  logn) + f(n) = tetha(n^log b tabanÄ±nda a)
                eÄŸer Ã¼Ã§Ã¼ncÃ¼ durum sÃ¶z konusu olduÄŸunda
          T(n) =     tetha(f(n)) + f(n) = omega(n^log b tabaÄ±nda a + epsilon) --> yani ikinci kÄ±sÄ±m daha baskÄ±n
                        bu durumda T(n) ifadesinin karmaÅŸÄ±klÄ±ÄŸÄ± f(n) ifadesine eÅŸit olacak
                        doÄŸrudan b parÃ§asÄ±nÄ± dikkate alÄ±rÄ±z yani
                tabi buralarda master teoremi uygulayabilmemiz iÃ§in;
                        a â‰¥ 1 olmalÄ±
                        b > 1 olmalÄ±
                        f(n) ifadesi asimptotic pozitif olmasÄ±nÄ± isteriz
                

YENÄ° KONU
MASTER TEOREM Ã–RNEKLERÄ°
- Master Theorem for Divide and Conquer
      T(n) = 2T(n/2)+o(n)
               ----   ---
                 a     b
                        
               a -> half-size of problem
               b -> work for merging
               
               
        T(n) = a.T(n/b)+tetha(n^k log^p n)
        where aâ‰¥1, b>1, kâ‰¥o
              p --> is a real number
        
        1. if a>b^k then;
              T(n)=tetha(n^logb^a . log^p+1 . n)
        2. if a=b^k      
              a. if p>-1    T(n)=tetha(n^logb^a log^p+1 n)
              b. if p=-1    T(n)=tetha(n^logb^a loglogn)
              c. if p<-1    T(n)=tetha(n.logb^a)
        3. if a<b^k
              a. if pâ‰¥0     T(n)=tetha(n^k log^p n)
              b. if p<0     T(n)=omega(n^k)



Example 1:
        T(n) = 9T(n/3)+n
        
        T(n) = 9T(n/3)+n
               ------  --
                  a     b       hangisi baskÄ±n olduÄŸuna bakacaÄŸÄ±z
                  
              ilk olarak kat sayÄ±lara bakÄ±lÄ±r.
              
              -   a=9   olarak verilmiÅŸ --> aâ‰¥1   koÅŸul tamam
              -   b=3                   --> b>1
              -   f(n)=n olarak tanÄ±mlanmÄ±ÅŸ, bu da asimptotic pozitif bir ifade doÄŸrusal olarak artan
              
              Bu Ã¼Ã§ kuralda yerine gelmiÅŸ master teorem uygulnabilir.
        
              Master teorem formÃ¼lÃ¼
              T(n) = a.T(n/b)+tetha(n)
        
              
              n^logb^a    <-->  n           a ve b kÄ±smÄ±nÄ±n karÅŸÄ±laÅŸtÄ±rmasÄ±nÄ± yapacaÄŸÄ±z.
              n^log3^3^2  <-->  n
                     ---
                      9
              n^2         <-->  n          n^2 ile n karÅŸÄ±laÅŸtÄ±rÄ±lÄ±r, sonuÃ§..
              
                      a   >     b          a>b olur. ilk terim daha baskÄ±n olduÄŸunu gÃ¶sterir.

              Bu sonuÃ§ bizi durum 1'e gÃ¶tÃ¼rÃ¼r.
              T(n) = tetha(n^logb^a)    f(n)=tetha(n^logb^a-epsilon)
                   = tetha(n^log3^3^2)
                   = tetha(n^2)         ----> ilgili ifadenin karmaÅŸÄ±klÄ±ÄŸÄ±nÄ± bu ÅŸekilde hesapladÄ±k.



Example 2:
        2T(n/2)+n
                  CevabÄ± sunum dosyasÄ±nda
              

Example 3:
   T(n)=4T(n/2)+n^2
   
        4T(n/2)+n^2
        ------- ---
            a    b
                                                                            Master teorem koÅŸullarÄ± uygun
            a = 4     --> problem 4 parÃ§aya ayrÄ±lmÄ±ÅŸ                    --> aâ‰¥1
            b = 2     --> her bir parÃ§anÄ±n uzunluÄŸu 2 olarak verilmiÅŸ   --> b>1
            f(n) = n^2  --> yani pozitif bir ifade var burda            --> pozitif
            
            KarÅŸÄ±laÅŸtÄ±rma
                n^logb^a    <-->  n^2
                
                n^log2^2^2  <-->  n^2
                n^2         <-->  n^2       --> bu noktada bir eÅŸitlik sÃ¶z konusu
                
                DolayÄ±sÄ±yla:
                a = b   bu eÅŸitlik sonucunda master teoremde 2.durumundan ilerleyeceÄŸiz

                Second Case:
                    T(n)= tetha(n^logb^a logn)    f(n)= tetha(n^logb^a)
                          --------------------
                              baskÄ±n ifade
                              
                           tetha(n^2logn)     --> sonuÃ§ bu ÅŸekilde Ã§Ä±kar


Example 4:
        T(n)=6T(n/3)+n^2logn
             
             6T(n/3) + n^2logn
             -------   -------
                a         b
                
            Ã‡Ã¶zÃ¼mÃ¼, sunum Ã¼zerinde var
            
Example 5:
        T(n)=16T(n/4)+n!
             -------- --
                 a    b
          
              a=16    ---> aâ‰¥1
              b=4     ---> b>1
              f(n)=n! ---> asimptotic pozitif
              
              n^logb^a   <--> n!
              n^log4^4^2 <--> n!
                    n^2  <--> n!
                    
                         a < b    master teoremde Ã¼Ã§Ã¼ncÃ¼ durumu uygulayacaÄŸÄ±z
                         
                         Case 3:
                              T(n)=tetha(f(n))    f(n)=omega(n^logb^a+epsilon)      epsilon-dÃ¼zeltme koÅŸulu. epsilon>1 olmalÄ±
                              
                              bu problem aslÄ±nda bizi yormayacak. doÄŸrudan f(n) karmaÅŸÄ±klÄ±ÄŸÄ± problemin karmaÅŸÄ±klÄ±ÄŸÄ± olacak.
                                  =tetha(n!)


Bu konuya kadar gÃ¶rÃ¼len matematik konularÄ±: Ã¼slÃ¼ sayÄ±lar, polinomlar, logaritma (Ã¶zellikle 2 tabanÄ±nda)
ğœ” â‰¤ xâ¿Â²Â³ã€‚â‚â‚‚ â‰¥ â‰ˆ 




YENÄ° ÃœNÄ°TE
YENÄ° KONU
DÄ°ZÄ°LERE GENEL BAKIÅ


Single Variable:      1

Array: Indexes        0   1  2   3   4
       Values         1   3  8   23  99

      Dizi tanÄ±mÄ± yaparken hafÄ±zada belli bir alana allocate edeyoruz yani yerini ayÄ±rÄ±yoruz
      SonrasÄ±nda, bu alanlarÄ±n her birine eriÅŸebilmek iÃ§in bir indexleme mekanizmasÄ± kuruyoruz. 
      BazÄ± prog dilleri zero based index yani sÄ±fÄ±r tabanlÄ± indexleme kullanÄ±r. genelde Ã¶yle oluyor ama bazÄ±larÄ± 1 tabanlÄ± indisleme mekanizmasÄ± kullanÄ±r.
      Dizileri incelediÄŸimiz de bu tek boyutlu diziler Ã¼zerinde sÄ±ralama vardÄ±r.
      Diziler tek ya da Ã§ok boyutlu olabilir tabi ki. Graf, Ã§izge gibi yapÄ±lar Ã§ok boyutlu olur. 
      
      â€¢ En temel veri yapÄ±larÄ±ndan biridir.
      â€¢ Dizi elemanlarÄ±na eriÅŸmek Ã¼zere genellikle sÄ±fÄ±r-tabanlÄ± indisleme (zero-based indexing) kullanÄ±lÄ±r.
      â€¢ Tek boyutlu (single-dimension) ya da Ã§ok-boyutlu (multi dimension)olabilir.
      â€¢ DÃ¼zenli (regular) ya da dÃ¼zensiz (jagged) olarak tanÄ±mlanabilir.
      â€¢ En bÃ¼yÃ¼k dezavantajÄ± sabit boyutlu olmasÄ±dÄ±r. Mutable-immutable durumu gibi. 
      â€¢ Dizinin sabit boyutlu olmasÄ±ndan dolayÄ± ekleme ve silme gibi iÅŸlemlerin maliyeti artar.
      â€¢ En bÃ¼yÃ¼k avantajÄ± ise bellek gÃ¶zlerine doÄŸrudan eriÅŸimin olmasÄ±dÄ±r.

      Dizilerin kullanÄ±ldÄ±ÄŸÄ± yerler:
        Obilet vs sistemlerde otobÃ¼s ya da uÃ§ak iÃ§indeki dolu ve boÅŸ koltuklarÄ± gÃ¶rebilmek
        AlÄ±ÅŸveriÅŸ sitesinde sepetini gÃ¶rebilmek
        Veri tabanÄ±nda bir grup kayÄ±t Ã¼zerinde iÅŸlem yaparken
        

    Dizinin sabit boyutlu olmasÄ± bizi kÄ±sÄ±tlar bunu yÃ¶netmek iÃ§in koleksiyon yapÄ±larÄ±na ihtiyacÄ±mÄ±z var.
    add(arr[],item)
    
    <-------N-------->
    -    -    -     -
    arr
    
    add(arr[], item)
    
            N+1
    -   -   -   -   - <--- new item        
    arr
    
            0(N)


YENÄ° KONU
PROJE ÅABLONU OLUÅTURMAK VSCODE'da mevcut




C# dilinde dizi tanÄ±mlamak
Example:
namespace Apps
{
  class Program
  {
    static void Main(string[] args)
    {
      // Array 
      char[] arrChar = new char[3];         // aÃ§Ä±k deÄŸiÅŸken tanÄ±mÄ±, Ã¶rtÃ¼lÃ¼ olsaydÄ± var derdik
                                            // Ã¼Ã§ elemanlÄ± bir char dizisi oluÅŸturduk (doÄŸrudan ilgili elemanlarÄ±n deÄŸerlerini tanÄ±mlarsak char[] arrChar = new char[3]; {'a','b','c'})
      
      var arrInt = Array.CreateInstance(typeof(int),5)   // BeÅŸ elemanlÄ± bir integer dizisi oluÅŸturmak istediÄŸimizi belli eder
                                                         // var arrInt =  bu ÅŸekilde tanÄ±m yapÄ±labilir
      // ArrayList
    
      // List<T>

      Console.ReadKey();
    }
  }
}











